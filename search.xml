<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git push 时如何避免出现 "Merge branch 'master' of ..."]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%20Merge%20branch%20master%20of%2F</url>
    <content type="text"><![CDATA[在使用 Git 的进行代码版本控制的时候，往往会发现在 log 中出现 “Merge branch ‘master’ of …” 这句话，如下图所示。日志中记录的一般为开发过程中对代码的改动信息，如果出现过多例如上述描述的信息会造成日志的污染。 阅读了一些外文的博客，下面就来一探究竟。 产生原因分析当多人合作开发一个项目时，本地仓库落后于远程仓库是一个非常正常的事情，可参考下图。 123A-B-C(master) \ D(origin/master) 具体情境如下： 我当前拉取的远端版本为 B，此时修改了代码，并在本地仓库 commit 一次，但并未 push 到远端仓库。 另一位开发者在 B 的基础上，同样 commit 了一次并 push 到远端仓库。那么这个时候，我再 push 自己的代码就会发生错误，如下。 1234567To github.com:maoqyhz/usegit.git! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;git@github.com:maoqyhz/usegit.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again. 这个时候我们会选择，先 pull，再 push。Ok，push 成功，但是此时我们查看 log 就会发现除了我们自己提交的那条日志之外，会多出一条 “Merge branch ‘master’ of …”。 那么，为什么会出现这种现象呢？其实是与 Git 的工作原理有关，对 Git 比较了解的人应该会知道，无论是 pull、push 亦或是 merge 操作，其实背后都是有很多的不同的模式的。 在进行 pull 操作的同时，其实就是 fetch+merge 的一个过程。我们从 remote 分支中拉取新的更新，然后再合并到本地分支中去。 如果 remote 分支超前于本地分支，并且本地分支没有任何 commit 的，直接从 remote 进行 pull 操作，默认会采用 fast-forward 模式，这种模式下，并不会产生合并节点，也就是说不会产生多余的那条 log 信息 如果想之前那样，本地先 commit 后再去 pull，那么此时，remote 分支和本地会分支会出现分叉，这个时候使用 pull 操作拉取更新时，就会进行分支合并，产生合并节点和 log 信息。这两种状态分别如下图所示：123456789# fast-forword A-B-D(origin/master) \ C&apos;(master)# mergeA-B-C-E(master) \ / D(origin/master) 如何避免为了去除自动生成的 log 信息，有以下几种解决方案： 如果你使用的是 Git Bash，直接使用 git pull --rebase。如果拉取不产生冲突，会直接 rebase，不会产生分支合并操作，如果有冲突则需要手动 fix 后，自行合并。 如果使用的是 GUI，例如 TortoiseGit，可以先 fetch，再手动 rebase 就可以了。 关于 rebase 和 merge关于什么时候使用 rebase，什么时候使用 merge，开发者总结了几条规则： 从 remote 分支拉取更新到本地时，使用 rebase。 当完成 bug 修复或新功能时，使用 merge 将子分支合并到主分支。 没有人应该 rebase 一根共享的分支。 有关这两者具体的操作，可以参考我在文章最后列出的博客。 References git-merge完全解析 git: Why “Merge branch ‘master’ of … ”? when pull and push 4 Ways to Avoid Merge Commits in Git (or How to Stop Being a Git Tit) Git rebase and the golden rule explained. Git - When to Merge vs. When to Rebase]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]通往 Java 函数式编程的捷径]]></title>
    <url>%2F2018%2F06%2F16%2F%E8%AF%91-%E9%80%9A%E5%BE%80Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8D%B7%E5%BE%84%2F</url>
    <content type="text"><![CDATA[原文地址：An easier path to functional programming in Java 原文作者：Venkat Subramaniam 译文出自：掘金翻译计划 以声明式的思想在你的 Java 程序中使用函数式编程技术Java™ 开发人员习惯于面向命令式和面向对象的编程，因为这些特性自 Java 语言首次发布以来一直受到支持。在 Java 8 中，我们获得了一组新的强大的函数式特性和语法。函数式编程已经存在了数十年，与面向对象编程相比，函数式编程通常更加简洁和达意，不易出错，并且更易于并行化。所以有很好的理由将函数式编程特性引入到 Java 程序中。尽管如此，在使用函数式特性进行编程时，就如何设计你的代码这一点上需要进行一些改变。 关于本文 Java 8 是 Java 语言自诞生以来最重要的更新，它包含如此多的新特性，以至于你可能想知道应该从哪开始了解它。在本系列中，身为作家和教育家的 Venkat Subramaniam 提供了一种符合 Java 语言习惯的 Java 8 学习方式。邀请你进行简短的探索后，重新思考你认为理所当然的 Java 一贯用法和规范，同时逐渐将新技术和语法集成到你的程序中去。 我认为，以声明式的思想而不是命令式的思想来编程，可以更加轻松地向更加函数化的编程风格过渡。在 Java 8 idioms series 这个系列的第一篇文章中，我解释了命令式、声明式和函数式编程风格之间的异同。然后，我将向你展示如何使用声明式的思想逐渐将函数式编程技术集成到你的 Java 程序中。 命令式风格（面向过程）受命令式编程风格训练的开发者习惯于告诉程序需要做什么以及如何去做。这里是一个简单的例子： 清单 1. 以命令式风格编写的 findNemo 方法 12345678910111213141516171819202122232425import java.util.*;public class FindNemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; names = Arrays.asList(&quot;Dory&quot;, &quot;Gill&quot;, &quot;Bruce&quot;, &quot;Nemo&quot;, &quot;Darla&quot;, &quot;Marlin&quot;, &quot;Jacques&quot;); findNemo(names); &#125; public static void findNemo(List&lt;String&gt; names) &#123; boolean found = false; for(String name : names) &#123; if(name.equals(&quot;Nemo&quot;)) &#123; found = true; break; &#125; &#125; if(found) System.out.println(&quot;Found Nemo&quot;); else System.out.println(&quot;Sorry, Nemo not found&quot;); &#125;&#125; 方法 findNemo() 首先初始化一个可变变量 flag，也称为垃圾变量（garbage variable）。开发者经常会给予某些变量一个临时性的名字，例如 f、t、temp 以表明它们根本不应该存在。在本例中，这些变量应该被命名为 found。 接下来，程序会循环遍历给定的 names 列表，每次都会判断当前遍历的值是否和待匹配值相同。在这个例子中，待匹配值为 Nemo，如果遍历到的值匹配，程序会将标志位设为 true，并执行流程控制语句 “break” 跳出循环。 这是对于广大 Java 开发者最熟悉的编程风格 —— 命令式风格的程序，因此你可以定义程序的每一步：你告诉程序遍历每一个元素，和待匹配值进行比较，设置标志位，以及跳出循环。命令式编程风格让你可以完全控制程序，有的时候这是一件好事。但是，换个角度来看，你做了很多机器可以独立完成的工作，这势必导致生产力下降。因此，有的时候，你可以通过少做事来提高生产力。 声明式风格声明式编程意味着你仍然需要告诉程序需要做什么，但是你可以将实现细节留给底层函数库。让我们看看使用声明式编程风格重写清单 1 中的 findNemo 方法时会发生什么： 清单 2. 以声明式风格编写的 findNemo 方法 123456public static void findNemo(List&lt;String&gt; names) &#123; if(names.contains(&quot;Nemo&quot;)) System.out.println(&quot;Found Nemo&quot;); else System.out.println(&quot;Sorry, Nemo not found&quot;);&#125; 首先需要注意的是，此版本中没有任何垃圾变量。你也不需要在遍历集合中浪费精力。相反，你只需要使用内建的 contains() 方法来完成这项工作。你仍然要告诉程序需要做什么，集合中是否包含我们正在寻找的值，但此时你已经将细节交给底层的方法来实现了。 在命令式编程风格的例子中，你控制了遍历的流程，程序可以完全按照指令进行；在声明式的例子中，只要程序能够完成工作，你完全不需要关注它是如何工作的。contains() 方法的实现可能会有所不同，但只要结果符合你的期望，你就会对此感到满意。更少的工作能够得到相同的结果。 训练自己以声明式的编程风格来进行思考将更加轻松地向更加函数化的编程风格过渡。原因在于，函数式编程风格是建立在声明式风格之上的。声明式风格的思维可以让你逐渐从命令式编程转换到函数式编程。 函数式编程风格虽然函数式风格的编程总是声明式的，但是简单地使用声明式风格编程并不等同与函数式编程。这是因为函数式编程时将声明式编程和高阶函数结合在了一起。图 1 显示了命令式，声明式和函数式编程风格之间的关系。 图 1. 命令式、声明式和函数式编程风格之间的关系 Java 中的高阶函数在 Java 中，你可以将对象传递给方法，在方法中创建对象，也可以从方法中返回对象。同时你也可以用函数做相同的事情。也就是说，你可以将函数传递给方法，在方法中创建函数，也可以从方法中返回函数。 在这种情况下，方法是类的一部分（静态或实例），但是函数可以是方法的一部分，并且不能有意地与类或实例相关联。一个可以接收、创建、或者返回函数的方法或函数称之为高阶函数。 一个函数式编程的例子采用新的编程风格需要改变你对程序的看法。这是一个从简单例子的练习开始，到构建更加复杂程序的过程。 清单 3. 命令式编程风格下的 Map 12345678910111213141516171819202122import java.util.*;public class UseMap &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; pageVisits = new HashMap&lt;&gt;(); String page = &quot;https://agiledeveloper.com&quot;; incrementPageVisit(pageVisits, page); incrementPageVisit(pageVisits, page); System.out.println(pageVisits.get(page)); &#125; public static void incrementPageVisit(Map&lt;String, Integer&gt; pageVisits, String page) &#123; if(!pageVisits.containsKey(page)) &#123; pageVisits.put(page, 0); &#125; pageVisits.put(page, pageVisits.get(page) + 1); &#125;&#125; 在清单 3 中，main() 函数创建了一个 HashMap 来保存网站访问次数。同时，incrementPageVisit() 方法增加了每次访问给定页面的计数。我们将聚焦此方法。 以命令式编程风格写的 incrementPageVisit() 方法：它的工作是为给定页面增加一个计数，并存储在 Map 中。该方法不知道给定页面是否已经有计数值，所以会先检查计数值是否存在，如果不存在，会为该页面插入一个值为”0”的计数值。然后再获取该计数值，递增它，并将新的计数值存储在 Map 中。 以声明式的方式思考需要你将方法的设计从 “how” 转变到 “what”。当 incrementPageVisit() 方法被调用时，你需要将给定的页面计数值初始化为 1 或者计数值加 1。这就是 what。 因为你是通过声明式编程的，那么下一步就是在 JDK 库中寻找可以完成这项工作且实现了 Map 接口的方法。换言之，你需要找到一个知道如何完成你指定任务的内建方法。 事实证明 merge() 方法非常适合你的而目的。清单 4 使用新的声明式方法对清单 3 中的 incrementPageVisit() 方法进行修改。但是，在这种情况下，你不仅仅只是选择更智能的方法来写出更具声明性风格的代码，因为 merge() 是一个更高阶的函数。所以说，新的代码实际上是一个体现函数式风格的很好的例子： 清单 4. 函数式编程风格下的 Map 123public static void incrementPageVisit(Map&lt;String, Integer&gt; pageVisits, String page) &#123; pageVisits.merge(page, 1, (oldValue, value) -&gt; oldValue + value); &#125; 在清单 4 中，page 作为第一个参数传递给 merge()：map 中键对应的值将会被更新。第二个参数作为初始值，如果 Map 中不存在指定键的值，那么该值将会赋值给 Map 中键对应的值（在本例中为”1”）。第三个参数为一个 lambda 表达式，接受当前 Map 中键对应的值和该函数中第二个参数对应的值作为参数。lambda 表达式返回其参数的总和，实际上增加了计数值。（编者注：感谢 István Kovács 修正了代码错误） 将清单 4 的 incrementPageVisit() 方法中的单行代码与清单 3 中的多行代码进行比较。虽然清单 4 中的程序是函数式编程风格的一个例子，但通过声明性地思想去思考问题帮助能够我们实现飞跃。 总结在 Java 程序中采用函数式编程技术和语法有很多好处：代码更简洁，更富有表现力，移动部分更少，实现并行化更容易，并且通常比面向对象的代码更易理解。 目前面临的挑战是，如何将你的思维从绝大多数开发人员所熟悉的命令式编程风格转变为以声明式的方式进行思考。 虽然函数式编程并没有那么简单或直接，但是你可以学习专注于你希望程序做什么而不是如何做这件事，来取得巨大的飞跃。通过允许底层函数库管理执行，你将逐渐直观地了解用于构建函数式编程模块的高阶函数。 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/an-easier-path-to-functional-programming-in-java.md 译者：maoqyhz 校对者：satansk、lihanxiang 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]深度学习中所需的线性代数知识]]></title>
    <url>%2F2018%2F06%2F08%2F%E8%AF%91-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E6%89%80%E9%9C%80%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[原文地址：Linear Algebra for Deep Learning 原文作者：Vihar Kurama 译文出自：掘金翻译计划 每个深度学习项目背后的数学知识。 深度学习是机器学习的一个子领域，涉及一些模仿人脑结构和功能的人工神经网络算法。 线性代数是一种连续的而非离散的数学形式，许多计算机科学家对它几乎没有经验。对于理解和使用许多机器学习算法，特别是深度学习算法，理解线性代数是非常重要的。 为什么是数学？线性代数，概率论和微积分是组成机器学习的三种“语言”。学习这些数学知识将有助于深入理解底层算法机制，并且开发新的算法。 当我们深入到底层时，深度学习背后的一切都是数学。因此在学习深度学习和编程之前，理解基本的线性代数知识是至关重要的。 源码 深度学习背后的核心数据结构是标量，矢量，矩阵和张量。让我们使用这些数据结构，通过编程的方式来解决所有基本的线性代数问题。 标量标量是单个数字，也可以视为 0 阶张量。符号 x∈ℝ 表示 x 是一个标量，属于一组实数值 ℝ。 以下是深度学习中不同数集的表示。ℕ 表示正整数集合 (1,2,3,…)。ℤ 表示结合了正值，负值和零值的整数集合。ℚ 表示有理数集合。 在 Python 中有一些内置的标量类型，int、float、complex、bytes and Unicode。在 Numpy（一个 Python 库）中，有 24 种新的基本数据类型来描述不同类型的标量。有关数据类型的信息，请参阅 文档。 在 Python 中定义标量和相关操作： 下面的代码段解释了一些运算运算符在标量中的应用。 123456789# 内置标量a = 5b = 7.5print(type(a))print(type(b))print(a + b)print(a - b)print(a * b)print(a / b) 123456&lt;class &apos;int&apos;&gt;&lt;class &apos;float&apos;&gt;12.5-2.537.50.6666666666666666 下面的代码段可以检查给出的变量是否为标量。 123456789101112import numpy as np# 判断是否为标量的函数def isscalar(num): if isinstance(num, generic): return True else: return Falseprint(np.isscalar(3.1))print(np.isscalar([3.1]))print(np.isscalar(False)) 123TrueFalseTrue 向量向量是单数的有序数组，是一阶张量的例子。向量是被称为矢量空间的对象的片段。向量空间可以被认为是特定长度（或维度）的所有可能向量的整个集合。用 ℝ^3 表示的三维实值向量空间，通常用于从数学角度表示我们对三维空间的现实世界概念。 为了明确地定位到矢量的某个分量，矢量的第 i 个标量元素被写为 x[i]。 在深度学习中，向量通常代表特征向量，其原始组成部分定义了具体特征的相关性。这些元素可以包括二维图像中一组像素的强度的相关重要性或者各种金融工具的历史价格值。 在 Python 中定义向量和相关操作： 123456789101112131415161718192021import numpy as np# 定义向量x = [1, 2, 3]y = [4, 5, 6]print(type(x))# 这样做不会得到向量和print(x + y)# 使用 Numpy 进行向量相加z = np.add(x, y)print(z)print(type(z))# 向量叉乘mul = np.cross(x, y)print(mul) 12345&lt;class &apos;list&apos;&gt;[1, 2, 3, 4, 5, 6][5 7 9]&lt;class &apos;numpy.ndarray&apos;&gt;[-3 6 -3] 矩阵矩阵是由数字组成的矩形阵列，是 2 阶张量的一个例子。如果 m 和 n 是正整数，即 m，n∈ℕ，则 m×n 矩阵包含 m*n 个数字，m 行 n 列。 完整的 m×n 矩阵可写为： 将全矩阵显示简写为以下表达式通常很有用： 在 Python 中，我们使用 Numpy 库来帮助我们创建 N 维数组。数组基本上可看做矩阵，我们使用矩阵方法，并通过列表来构造一个矩阵。 $python 123456789101112131415161718192021&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; x = np.matrix([[1,2],[2,3]])&gt;&gt;&gt; xmatrix([[1, 2], [2, 3]])&gt;&gt;&gt; a = x.mean(0)&gt;&gt;&gt; amatrix([[1.5, 2.5]])&gt;&gt;&gt; # 对矩阵求均值。（其中 axis 不设置值，对 m*n 个数求均值，返回一个实数；axis = 0：压缩行，对各列求均值，返回 1* n 矩阵；axis =1 ：压缩列，对各行求均值，返回 m *1 矩阵）。&gt;&gt;&gt; z = x.mean(1)&gt;&gt;&gt; zmatrix([[1.5], [2.5]])&gt;&gt;&gt; z.shape(2, 1)&gt;&gt;&gt; y = x - zmatrix([[-0.5, 0.5], [-0.5, 0.5]])&gt;&gt;&gt; print(type(z))&lt;class &apos;numpy.matrixlib.defmatrix.matrix&apos;&gt; 在 Python 中定义矩阵和相关操作： 矩阵加法矩阵可以与标量、向量和其他矩阵进行加法运算。每个操作都有精确的定义。这些技术经常用于机器学习和深度学习，所以值得花时间去熟悉它们。 123456789# 矩阵加法import numpy as npx = np.matrix([[1, 2], [4, 3]])sum = x.sum()print(sum)# Output: 10 矩阵与矩阵相加C = A + B (A 与 B 的维度需要相同 ) shape 方法返回矩阵的维度，add 方法接受两个矩阵参数并返回这两个矩阵的和。如果两个矩阵的维度不一致 add 方法将会抛出一个异常，说无法将其相加。 123456789101112131415161718192021# 矩阵与矩阵相加import numpy as npx = np.matrix([[1, 2], [4, 3]])y = np.matrix([[3, 4], [3, 10]])print(x.shape)# (2, 2)print(y.shape)# (2, 2)m_sum = np.add(x, y)print(m_sum)print(m_sum.shape)&quot;&quot;&quot;Output :[[4 6] [7 13]](2, 2)&quot;&quot;&quot; 矩阵与标量相加将给定的标量添加到给定矩阵中的所有元素。 123456789101112# 矩阵与标量相加import numpy as npx = np.matrix([[1, 2], [4, 3]])s_sum = x + 1print(s_sum)&quot;&quot;&quot;Output:[[2 3] [5 4]]&quot;&quot;&quot; 矩阵与标量的乘法将给定的标量乘以给定矩阵中的所有元素。 1234567891011# 矩阵与标量的乘法import numpy as npx = np.matrix([[1, 2], [4, 3]])s_mul = x * 3print(s_mul)&quot;&quot;&quot;[[3 6] [12 9]]&quot;&quot;&quot; 矩阵乘法维度为（m x n）的矩阵 A 和维度为（n x p）的矩阵 B 相乘，最终得到维度为（m x p）的矩阵 C。 源码 123456789101112# 矩阵乘法import numpy as npa = [[1, 0], [0, 1]]b = [1, 2]np.matmul(a, b)# Output: array([1, 2])complex_mul = np.matmul([2j, 3j], [2j, 3j])print(complex_mul)# Output: (-13+0j) 矩阵转置通过转置，您可以将行向量转换为列向量，反之亦然： A=[a_ij_]mxn AT=[a_ji_]n×m 1234567891011121314151617# 矩阵转置import numpy as npa = np.array([[1, 2], [3, 4]])print(a)&quot;&quot;&quot;[[1 2] [3 4]]&quot;&quot;&quot;a.transpose()print(a)&quot;&quot;&quot;array([[1, 3], [2, 4]])&quot;&quot;&quot; 张量更加泛化的实体 —— 张量，封装了标量、矢量和矩阵。在物理科学和机器学习中，有时需要使用超过两个顺序的张量。 源码 我们使用像 TensorFlow 或 PyTorch 这样的 Python 库来声明张量，而不是使用嵌套矩阵来表示。 在 PyTorch 中定义一个简单的张量： 123456789101112131415161718192021222324import torcha = torch.Tensor([26])print(type(a))# &lt;class &apos;torch.FloatTensor&apos;&gt;print(a.shape)# torch.Size([1])# 创建一个 5*3 的随机 torch 变量。t = torch.Tensor(5, 3)print(t)&quot;&quot;&quot; 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 7.0065e-45 1.1614e-41 0.0000e+00 2.2369e+08 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 nan nan -1.4469e+35[torch.FloatTensor of size 5x3]&quot;&quot;&quot;print(t.shape)# torch.Size([5, 3]) Python 中张量的运算操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import torch# 创建张量p = torch.Tensor(4,4)q = torch.Tensor(4,4)ones = torch.ones(4,4)print(p, q, ones)&quot;&quot;&quot;Output: 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 1.6009e-19 4.4721e+21 6.2625e+22 4.7428e+30 3.1921e-09 8.0221e+17 5.1019e-08 8.1121e+17 8.1631e-07 8.2022e+17 1.1703e-19 1.5637e-01[torch.FloatTensor of size 4x4] 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 1.8217e-44 1.1614e-41 0.0000e+00 2.2369e+08 0.0000e+00 0.0000e+00 2.0376e-40 2.0376e-40 nan nan -5.3105e+37 nan[torch.FloatTensor of size 4x4] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1[torch.FloatTensor of size 4x4]&quot;&quot;&quot;print(&quot;Addition:&#123;&#125;&quot;.format(p + q))print(&quot;Subtraction:&#123;&#125;&quot;.format(p - ones))print(&quot;Multiplication:&#123;&#125;&quot;.format(p * ones))print(&quot;Division:&#123;&#125;&quot;.format(q / ones))&quot;&quot;&quot;Addition: 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 1.6009e-19 4.4721e+21 6.2625e+22 4.7428e+30 3.1921e-09 8.0221e+17 5.1019e-08 8.1121e+17 nan nan -5.3105e+37 nan[torch.FloatTensor of size 4x4]Subtraction:-1.0000e+00 -1.0000e+00 -1.0000e+00 -1.0000e+00-1.0000e+00 4.4721e+21 6.2625e+22 4.7428e+30-1.0000e+00 8.0221e+17 -1.0000e+00 8.1121e+17-1.0000e+00 8.2022e+17 -1.0000e+00 -8.4363e-01[torch.FloatTensor of size 4x4]Multiplication: 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 1.6009e-19 4.4721e+21 6.2625e+22 4.7428e+30 3.1921e-09 8.0221e+17 5.1019e-08 8.1121e+17 8.1631e-07 8.2022e+17 1.1703e-19 1.5637e-01[torch.FloatTensor of size 4x4]Division: 0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00 1.8217e-44 1.1614e-41 0.0000e+00 2.2369e+08 0.0000e+00 0.0000e+00 2.0376e-40 2.0376e-40 nan nan -5.3105e+37 nan[torch.FloatTensor of size 4x4]&quot;&quot;&quot; 有关张量和 PyTorch 的更多文档点击这里。 重要的链接 在 Python 中入门深度学习： Deep Learning with Python: The human brain imitation. Introduction To Machine Learning: Machine Learning is an idea to learn from examples and experience, without being explicitly programmed. Instead of… 结束语感谢阅读。如果你发现这个故事很有用，请点击下面的 👏 来传播爱心。 特别鸣谢 Samhita Alla 对本文的贡献。 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/linear-algebra-for-deep-learning.md 译者：maoqyhz 校对者：kezhenxu94、luochen1992 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>AI</tag>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 恶意样本数据集汇总]]></title>
    <url>%2F2018%2F06%2F01%2FAndroid%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[硕士论文的研究方向为Android恶意应用分类，因此花了一点时间去搜集Android恶意样本。其中一部分来自过去论文的公开数据集，一部分来自社区或平台的样本。现做一个汇总，标明了样本或数据集的采集时间、样本数量、对于论文以及获取方式。 List some android malware datasets in academic research.Some of them are still up to date. 我这里有Drebin的数据集，以及VirusTotal（2018.3）的android恶意样本，约15GB。VirusTotal的数据集在Google云盘上,Drebin数据集我上传了2560个到OneDrive（由于空间受限）。需要的可联系我本人（分享Google云盘需要提供你的gmail）。 历史的数据集例如Drebin、Genome 等可以联系导师，然后发邮件联系他们获取，一些不再共享的也可以联系一些已经拥有数据集的大学和机构，基本上国内知名的大学都会有这些数据集。 VirusTotal的样本可以自己去申请。分为API和恶意文件夹。前者可以等到详细的样本检测报告，后者的话主要是大量的恶意样本。但是VirusTotal样本申请需要填写大量的信息，例如身份、研究的内容、学校和导师的资料等。 Contagio样本的密码，直接联系博主本人即可。 所有样本仅可用于学术研究，并且请指出样本来源。 VirusTotal Mobile Apps Samples VirusTotal: Analyze suspicious files and URLs to detect types of malware including viruses, worms, and trojans. Description: VirusTotal can also be used through a smartphone app. VirusTotal is about empowering the Community in order to build tools that will make the Internet a safer place, as such, we like to credit and feature Community-developed goodies that help the antivirus industry in receiving more files in order to have more visibility into threats. Below you can find links to apps that will allow you to interact with VirusTotal making use of your smartphone, note that these are not developed by VirusTotal itself and so we are not responsible for them. Sample Volume: N/A Collected Time: up to date HomePage: https://www.virustotal.com Way to get: If you need a small volume of sample, login to VirusTotal and download manually. If you need a large volume of sample, email to virusTotal for academic requests. You can choose “access to the Academic API” or “access to a folder of malware” Contagio Mobile Malware Mini DumpDescription: aka “take a sample, leave a sample”Contagio mobile mini-dump is a part of contagiodump.blogspot.com. Contagio mobile mini-dump offers an upload dropbox for you to share your mobile malware samples. You can also download any samples individually or in one zip. Sample Volume: N/A Collected Time: up to date HomePage: http://contagiominidump.blogspot.hk/ Way to get: free for download in Contagio blogs.And you can also download the sample from this link: http://contagiomobile.deependresearch.org/index.html However, the package need password to decompress, you need to email bloger to get password. KoodousDescription: Koodous is a collaborative platform that combines the power of online analysis tools with social interactions between the analysts over a vast APKs repository. Sample Volume: N/A Collected Time: up to date HomePage: https://koodous.com/ Way to get: register and download manually or use the api. The Drebin DatasetDescription: The dataset contains 5,560 applications from 179 different malware families. The samples have been collected in the period of August 2010 to October 2012 and were made available to us by the MobileSandbox project. Sample Volume: 5,560 applications from 179 different malware families Collected Time: 2010.8 - 2012.10 Papers: Daniel Arp, Michael Spreitzenbarth, Malte Huebner, Hugo Gascon, and Konrad Rieck “Drebin: Efficient and Explainable Detection of Android Malware in Your Pocket”, 21th Annual Network and Distributed System Security Symposium (NDSS), February 2014 Michael Spreitzenbarth, Florian Echtler, Thomas Schreck, Felix C. Freling, Johannes Hoffmann, “MobileSandbox: Looking Deeper into Android Applications”, 28th International ACM Symposium on Applied Computing (SAC), March 2013 HomePage: https://www.sec.cs.tu-bs.de/~danarp/drebin/index.html Way to get: send email Android Malware Genome Project (2015/12/21) Due to limited resources and the situation that students involving in this project have graduated, we decide to stop the efforts of malware dataset sharing. Description: In this project, we focus on the Android platform and aim to systematize or characterize existing Android malware. Particularly, with more than one year effort, we have managed to collect more than 1,200 malware samples that cover the majority of existing Android malware families, ranging from their debut in August 2010 to recent ones in October 2011. Sample Volume: more than 1,200 Collected Time: 2010.8 - 2011.10 Papers: Yajin Zhou, Xuxian Jiang, Dissecting Android Malware: Characterization and Evolution. Proceedings of the 33rd IEEE Symposium on Security and Privacy (Oakland 2012). San Francisco, CA, May 2012 HomePage: http://www.malgenomeproject.org/ Way to get: ask someone who had already get this dataset. following universities, research labs and companies Kharon Malware DatasetDescription: The Kharon dataset is a collection of malware totally reversed and documented. This dataset has been constructed to help us to evaluate our research experiments. Its construction has required a huge amount of work to understand the malicous code, trigger it and then construct the documentation. This dataset is now available for research purpose, we hope it will help you to lead your own experiments. Papers: CIDRE, EPI. Kharon dataset: Android malware under a microscope. Learning from Authoritative Security Experiment Results (2016): 1. Homepage: http://kharon.gforge.inria.fr/dataset/ AMD ProjectDescription: AMD contains 24,553 samples, categorized in 135 varieties among 71 malware families ranging from 2010 to 2016. The dataset provides an up-to-date picture of the current landscape of Android malware, and is publicly shared with the community. Sample Volume: 24,553 samples Collected Time: 2010 to 2016 PapersLi Y, Jang J, Hu X, et al. Android malware clustering through malicious payload mining[C]//International Symposium on Research in Attacks, Intrusions, and Defenses. Springer, Cham, 2017: 192-214. Wei F, Li Y, Roy S, et al. Deep Ground Truth Analysis of Current Android Malware[C]//International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment. Springer, Cham, 2017: 252-276. Homepage: http://amd.arguslab.org 更多有关于Android恶意分类的资料，可访问我的github。项目地址为：DroidCC，里面包含了Android恶意检测的工具、最近的参考文献、第三方应用市场等资料。]]></content>
      <categories>
        <category>技术云云</category>
      </categories>
      <tags>
        <tag>Android Malware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『风物长宜放眼量』——序]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%8E%E9%A3%8E%E7%89%A9%E9%95%BF%E5%AE%9C%E6%94%BE%E7%9C%BC%E9%87%8F%E3%80%8F%E2%80%94%E2%80%94%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[为个人博客作个序。 3年6个月从博客园搬到了自己搭建的个人博客，日子说长不长，说短也不算短。记得当年刚读本科，什么都不会，刷了一年杭电OJ的水题，就开始跟着老师做起项目来了。当时就有一个同学，无论上课还是下课，都捏着不放，一直都在浏览技术博客，学的技术永远超前过我们所有人，毕业那会已经是CSDN的博客专家了。深谙出名要趁早之道的他，可以说是年少得志，心高气傲，却也的确有这个资本。除了老师，我觉得本科四年，最应该感谢的就是这位了吧，区长。技术上的问题，他能够给出解决方案的同时，亦会有自己的真知灼见，每每去请教问题，也总能得到自己想要的答案。 在坚持写技术博客这件事情上，也是跟他学习的。三年半的时间里，虽然自己的成就远不如区长，但是也一直坚持下来了，从一开始的读书笔记、小水文，到现在也能写出几篇相对有质量的博客（说不上质量高，也总算对他人有一定帮助）。对于技术的passion虽不及区长，但亦有自己的理想。写出一篇博客，即是对自己的知识掌握的肯定，又能够帮助广大的开发者，绝对是一件非常有意义的事情。收获的鲜花和掌声，能够让自己更好的进行下去。现在我又再次效仿区长，开了个个人博客，在写一些技术博客之余，也会写一些其他的见解。 人是思想的芦苇，写技术博客所展现的就是对技术的一种思考，并没有太多的功利性，借用毛主席的一句诗——风物长宜放眼量，博观而约取，厚积而薄发。 To be continued. 在最后奉上区老师的博客地址：fucknmb.com]]></content>
      <categories>
        <category>思无邪</category>
      </categories>
      <tags>
        <tag>序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客搭建以及 Next 主题美化的经验之谈]]></title>
    <url>%2F2018%2F05%2F19%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8ANext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88%2F</url>
    <content type="text"><![CDATA[这并不是一篇博客搭建教程。内容主要包含个人对于Hexo博客搭建的心得，Next6.0主题美化的部分建议，以及摘录一些各种用于博客搭建的link。 惯例，第一篇博客献给Hexo。 个人博客的搭建不外乎两种，类似Wordpress的动态博客，类似Hexo的静态博客。前者搭建好了之后维护起来还是比较方便的，不管是发文还是添加分类等等都可以在后台管理中进行；而后者则需要手动进行管理，从博客的美化到内容的维护，当然也存在hexo-admin这类的插件。However，前者需要一个服务器，emmm，后者的话托管在github或者coding就ok，短时间内能用完100M的估计也是人才了。 Absolutely，博主选择了后者。Hexo的教程网上多了去了，也写的够详尽够简单了，毕竟Hexo本来也就是一个快速的blog搭建工具，因此也就不再写完整教程了。下面我会写一些针对于当前版本的Hexo以及最受欢迎的主题Next的一些tips，主要内容如下： 搭建一个Hexo&amp;Next的最小博客系统 Next主题美化心得 域名绑定 关于博客图片 备份维护的Tips 搭建一个Hexo&amp;Next的最小博客系统论最小系统的重要性。对于任何一个需要搭建的系统，无论是博客还是论坛，我都推荐新手先根据教程搭建一个最小系统。最小系统顾名思义，就是一个满足需求的最小化的系统。举个栗子，比如你需要搭建Wordpress，这个时候我们就可以先搭建一个最基本的Wordpress博客，即可以进行内容的发布和管理，然后再根据自己的需求去进行主题的美化和插件安装等等，这样操作会更具有条理性。完全没有必要第一次就期望能够顺利搭建完成，直接用于实际生产应用环境。 再看Hexo，Hexo搭建的过程就是单纯的配置文件形式和命令行。有些教程写的非常长，从安装环境、本地部署、美化、第三方插件写到域名、SEO优化等等。内容太多，太复杂，这对于新手就显得不那么友好了。因此在这里，我仅仅描述了如何搭建一个Hexo&amp;Next的最小博客系统，不夹杂其余一些美化优化等操作，待大家玩熟了之后，再进行一些高级的配置。最小博客系统的搭建分为以下几个步骤： 本地环境搭建（Git、Node.js） Github创建博客仓库，初始化GitHub Pages 本地搭建Hexo博客 部署到GitHub Pages . 主题美化 Attention： 这里未包含域名绑定的过程，因为无论GitHub Pages还是Coding Pages，都可以通过用户名自带的域名访问，如果购买了域名的，可参考附录进行域名绑定。 1-4步具体的过程可参考GitHub Pages + Hexo搭建博客，按照这篇博客的步骤走，基本上几分钟时间就可以搭建一个默认主题的Hexo博客了。 默认的主题并不是那么好看，这里我们选择目前最流行的Hexo Next主题，该主题非常简洁，并且有非常详细的配置文档，对于不愿意花大时间在博客美化上的人来说，是极好的。 主题应用具体可参考Next官方文档，我们需要根据文档配置一下信息： Scheme 语言 菜单，包括标签、分类、关于等 作者昵称和站点描述 经过以上几个步骤的配置，一个基本的个人博客就已经成型了，可以在上面进行内容的发布，这也就是上面所提到的一个最小系统。 Next主题美化心得搭建完最小系统的Hexo博客，其实已经可以正常工作了。但是Next主题给了我们更多DIY的空间，根据官方配置文档，我们还能配置例如评论、统计分析、搜索等其他一系列的功能。大家可以根据自己的喜好进行配置。 但是，需要提出的就是，Hexo本身主打的是轻量级博客系统，过多的美化可能会导致博客的卡顿。因此，我只推荐以下个性化设置： Github banner在Next6.0之后，配置自带github_banner，只需要在后面添加自己的github地址即可，例如： 1github_banner: https://github.com/maoqyhz || Follow me on GitHub 博文置顶 评论系统和单篇文章统计这里把这两部分何在一起，主要他们都用到了LeanCloud服务。LeanCloud是一个后端服务商，我们在上面注册后，就可以免费使用其统计和评论的服务。当然，据说leancloud_visitors有一个安全问题，对此比较敏感的可通过Leancloud访客统计插件重大安全漏洞修复指南进行手动修复，也可忽略。 全站统计 开启本地搜索 博客字数统计和阅读所需时间旧版的next主题使用的是hexo-wordcount插件，新版已替换成hexo-symbols-count-time 上述的美化配置，均可在Next官方文档和hexo的next主题个性化教程:打造炫酷网站中找到。 域名绑定github page自带二级域名，同时也支持绑定个人域名。 域名其实分为注册和绑定两部分。 第一，需要去域名服务商哪里购买域名，国内：万网、Dnspod；国外选择余地就更大了，具体的价格可参考www.domcomp.com。博主是在namesilo里买的，价格相对比较便宜。 第二，域名绑定。如果是像博主这样在国外服务商买的域名，一般就不使用其域名解析服务（NS）了，可以换成国内的Dnspod。然后设置别名即可，不需要添加A记录。 具体操作如下： 更换域名服务商的NS，以namesilo为例。 在Dnspod中添加域名和记录。 在博客源文件source/目录下创建一个无文件类型的文件CNAME，并添加自己的域名，例如furur.xyz。更新部署到github上。 由于NS修改需要时间，过一段时间可以刷新下网页看看。 关于博客图片Hexo博客搭建完后，大多会选择部署到Github Pages或者Coding Pages上去，这时候由于空间问题，大家可能会对于博客中的图片放哪的问题存在困惑。网上大多数的人都推荐使用各种图床或者云服务（七牛云）。但是个人觉得如果不是嫌图片加载的速度过慢，其实直接上传图片到github就可以了。Github Pages每人的空间有100M，毕竟技术博客中包含的图片有限，实在有大图，可以先进行在线压缩。一般一篇博客1M都不到，待有恒心写满100篇博客在说吧。上传图片，需要将Hexo配置文件中的post_asset_folder设为true，然后在博客创建时，会在source文件夹下创建于博客同名的文件夹。在里面放图片，博客中直接引用文件名即可。 备份维护的TipsHexo博客需要本地静态部署后，push到服务器上去。善于思考的，应该会想到如果换电脑了，应该如何继续写博客部署到服务器上去呢？具体可参考使用hexo，如果换了电脑怎么更新博客？ 其实原理很简单，知乎中提到的这么多方法，无非就是将除了部署生成的文件之外，其余的文件夹以及配置文件都单独保存好即可。保存的方法自然有很多，可以新建一个源代码分支，也可单独用云服务进行备份。 总结对于coding相关的人来说，Hexo的搭建可以说是非常简单了，加上网上资料丰富，大家可以随意折腾~~~ 附录教程列表 GitHub Pages + Hexo搭建博客 Hexo搭建博客教程 Hexo+GithubPages&amp;CodingPages搭建自己的个人博客 备份维护 使用hexo，如果换了电脑怎么更新博客？ 主题美化 hexo的next主题个性化教程:打造炫酷网站 为NexT主题添加文章阅读量统计功能 Hexo博客添加文章置顶功能 插件 hexo-git-backup hexo-admin]]></content>
      <categories>
        <category>技术云云</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-next</tag>
      </tags>
  </entry>
</search>
